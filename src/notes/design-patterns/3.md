---
title: 策略模式
isOriginal: true
order: 3
cover: https://images.icestream32.cn/images/2024/11/09/118435175_p0_master1200.jpg
category:
    - 计算机
    - 读书笔记
    - 设计模式
tag:
    - 策略模式
    - TypeScript
    - Golang
---

<!-- more -->

## 定义

策略模式（Strategy Pattern）：定义一系列算法，将每一个算法封装起来，并使它们可以相互替换，从而使得算法独立于使用它的客户而独立变化。

## 书中案例实现

场景：商场收银软件，根据不同的商品打折方式计算价格。

### UML类图

@startuml
interface CashSuper {
    +acceptCash(money: number): number
}

class CashNormal {
    +acceptCash(money: number): number
}

class CashRebate {
    -rebate: number
    +constructor(rebate: number)
    +acceptCash(money: number): number
}

class CashReturn {
    -condition: number
    -result: number
    +constructor(condition: number, moneyReturn: number)
    +acceptCash(money: number): number
}

class CashContext {
    -cs: CashSuper
    +constructor(type: string)
    +getResult(money: number): number
}

CashSuper <|-- CashNormal
CashSuper <|-- CashRebate
CashSuper <|-- CashReturn
CashContext o-- CashSuper
@enduml

## 代码

::: tabs

@tab TypeScript

```ts
interface ICashSuper {
    acceptCash(money: number): number;
}

class CashNormal implements ICashSuper {
    acceptCash(money: number): number {
        return money;
    }
}

class CashRebate implements ICashSuper {
    private readonly _rebate: number;

    public constructor(rebate: number) {
        this._rebate = rebate;
    }

    public acceptCash(money: number): number {
        return money * this._rebate;
    }
}

class CashReturn implements ICashSuper {
    private readonly _condition: number;
    private readonly _moneyReturn: number;

    public constructor(condition: number, moneyReturn: number) {
        this._condition = condition;
        this._moneyReturn = moneyReturn;
    }

    public acceptCash(money: number): number {
        return money - Math.floor(money / this._condition) * this._moneyReturn;
    }
}

class CashContext {
    private _cs: ICashSuper;

    public constructor(type: number) {
        switch (type) {
            case 1:
                this._cs = new CashNormal(); // 正常收费
                break;
            case 2:
                this._cs = new CashRebate(0.7); // 打75折
                break;
            case 3:
                this._cs = new CashReturn(300, 100); // 满300减100
                break;
            default:
                throw new Error('不支持的收费类型');
        }
    }

    public getResult(money: number): number {
        return this._cs.acceptCash(money);
    }
}

(async () => {
    const money = 500;
    const cashType = 2;
    const cc = new CashContext(cashType);
    console.log(cc.getResult(money));
})()

```
@tab Golang

```go
package strategy

type cashSuper interface {
	acceptCash(money float64) float64
}

type cashNormal struct {
}

func (c *cashNormal) acceptCash(money float64) float64 {
	return money
}

type cashRebate struct {
	rebate float64
}

func (c *cashRebate) acceptCash(money float64) float64 {
	return money * c.rebate
}

type cashReturn struct {
	condition   float64
	moneyReturn float64
}

func (c *cashReturn) acceptCash(money float64) float64 {
	return money - float64(int(money/c.condition))*c.moneyReturn
}

type cashContext struct {
	cs cashSuper
}

func (c *cashContext) GetResult(money float64) float64 {
	return c.cs.acceptCash(money)
}

func NewCashContext(cashType int) *cashContext {
	switch cashType {
	case 1:
		return &cashContext{&cashNormal{}} // 正常收费
	case 2:
		return &cashContext{&cashRebate{0.75}} // 75折
	case 3:
		return &cashContext{&cashReturn{300, 100}} // 满300减100
	default:
		panic("不支持的收费类型")
	}
}
```

:::

::: tip

- 在正常开发中，`cashType`一般设定成枚举值
- TS`Math.floor`方法是向下取整，Golang中的`int`是向0取整
- Go中的结构体全都是小写，只向外暴露一个方法，这样就实现了类似于私有属性的效果

:::

## 总结

策略模式是一种定义一系列算法的方法，从概念上来看，所有这些算法完成的都是相同的工作，只是实现不同，它可以以相同的方式调用所有的算法，减少了各种算法类与使用算法类之间的耦合。

但是还是得需要在策略类中实现switch选择，一旦策略过多就会变得臃肿不堪，之后学习的抽象工厂模式会使用反射来解决这个问题。

::: info

封面来源：[Pixiv](https://www.pixiv.net/artworks/118435175) <br>
参考书籍：[《大话设计模式》](http://www.tup.tsinghua.edu.cn/booksCenter/book_09792501.html)

:::
