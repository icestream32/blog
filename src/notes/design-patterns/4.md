---
title: 装饰模式
isOriginal: true
order: 4
cover: https://images.icestream32.cn/images/2024/11/25/119168789_p0_master1200.jpg
category:
    - 计算机
    - 读书笔记
    - 设计模式
tag:
    - 装饰模式
    - TypeScript
    - Golang
---

装饰模式（Decorator Pattern）：动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。

<!-- more -->

## 书中案例实现

### 案例1

场景：人物穿衣服，可以搭配不同的服饰。

#### UML类图

@startuml
interface ICharacter {
    +show()
}

class Person {
    -name: string
    +constructor(name: string)
    +show()
}

ICharacter ..|> Person

class Finery {
    -component: ICharacter
    +constructor(component: ICharacter)
    +decorator(component: ICharacter)
    +show()
}

ICharacter ..|> Finery

class TShirts {
    +show()
}

class BigTrouser {
    +show()
}

class Sneakers {
    +show()
}

class Suit {
    +show()
}

class Tie {
    +show()
}

class LeatherShoes {
    +show()
}

Finery --|> TShirts
Finery --|> BigTrouser
Finery --|> Sneakers
Finery --|> Suit
Finery --|> Tie
Finery --|> LeatherShoes
@enduml

#### 代码实现

::: tabs

@tab TypeScript

```ts
interface ICharacter {
    show(): void;
}

class Person implements ICharacter {
    private _name: string;

    public constructor(name: string) {
        this._name = name;
    }

    show(): void {
        console.log(`${this._name}`);
    }
}

class Finery implements ICharacter {
    private _component: ICharacter;

    public decorate(component: ICharacter) {
        this._component = component;
    }

    public show(): void {
        if (!this._component) {
            console.log('没有装饰');
            return;
        }
        this._component.show();
    }
}

class TShirts extends Finery {
    show(): void {
        console.log('穿着大T恤');
        super.show();
    }
}

class BigTrouser extends Finery {
    show(): void {
        console.log('穿着大裤衩');
        super.show();
    }
}

class Sneakers extends Finery {
    show(): void {
        console.log('穿着球鞋');
        super.show();
    }
}

class Suit extends Finery {
    show(): void {
        console.log('穿着西装');
        super.show();
    }
}

class Tie extends Finery {
    show(): void {
        console.log('穿着领带');
        super.show();
    }
}

class LeatherShoes extends Finery {
    show(): void {
        console.log('穿着皮鞋');
        super.show();
    }
}

(async () => {
    const person = new Person('Tom');
    const tShirts = new TShirts();
    const bigTrouser = new BigTrouser();
    const sneakers = new Sneakers();
    const suit = new Suit();
    const tie = new Tie();
    const leatherShoes = new LeatherShoes();

    // 展示一个人穿着大T恤、大裤衩、球鞋
    tShirts.decorate(person);
    bigTrouser.decorate(tShirts);
    sneakers.decorate(bigTrouser);
    sneakers.show();

    // 展示一个人穿着西装、领带、皮鞋
    suit.decorate(person);
    tie.decorate(suit);
    leatherShoes.decorate(tie);
    leatherShoes.show();
})()
```

@tab Golang

```go
// decorator_case1.go
package decorator

import "fmt"

type iCharacter interface {
	Show()
}

type person struct {
	name string
}

func NewPerson(name string) *person {
	return &person{name: name}
}

func (p *person) Show() {
	fmt.Println(p.name)
}

type finery struct {
	Component iCharacter
}

func newFinery() *finery {
	return &finery{}
}

func (f *finery) Decorator(component iCharacter) {
	f.Component = component
}

func (f *finery) Show() {
	if f.Component != nil {
		f.Component.Show()
	}
}

type tShirts struct {
	Component *finery
}

func NewTShirts() *tShirts {
	return &tShirts{Component: newFinery()}
}

func (t *tShirts) Show() {
	fmt.Println("穿着大T恤")

	if t.Component != nil {
		t.Component.Show()
	}
}

type bigTrouser struct {
	Component *finery
}

func NewBigTrouser() *bigTrouser {
	return &bigTrouser{Component: newFinery()}
}

func (b *bigTrouser) Show() {
	fmt.Println("穿着大裤衩")

	if b.Component != nil {
		b.Component.Show()
	}
}

type sneakers struct {
	Component *finery
}

func NewSneakers() *sneakers {
	return &sneakers{Component: newFinery()}
}

func (s *sneakers) Show() {
	fmt.Println("穿着球鞋")

	if s.Component != nil {
		s.Component.Show()
	}
}

type suit struct {
	Component *finery
}

func NewSuit() *suit {
	return &suit{Component: newFinery()}
}

func (s *suit) Show() {
	fmt.Println("穿着西装")

	if s.Component != nil {
		s.Component.Show()
	}
}

type tie struct {
	Component *finery
}

func NewTie() *tie {
	return &tie{Component: newFinery()}
}

func (t *tie) Show() {
	fmt.Println("穿着领带")

	if t.Component != nil {
		t.Component.Show()
	}
}

type leatherShoes struct {
	Component *finery
}

func NewLeatherShoes() *leatherShoes {
	return &leatherShoes{Component: newFinery()}
}

func (l *leatherShoes) Show() {
	fmt.Println("穿着皮鞋")

	if l.Component != nil {
		l.Component.Show()
	}
}

// main.go
package main

import (
	decorator "design-patterns/04-decorator"
)

func main() {
	name := "Tom"
	p := decorator.NewPerson(name)

	// 第一套装扮
	tShirt := decorator.NewTShirts()
	bigTrouser := decorator.NewBigTrouser()
	sneakers := decorator.NewSneakers()

	tShirt.Component.Decorator(p)
	bigTrouser.Component.Decorator(tShirt)
	sneakers.Component.Decorator(bigTrouser)

	sneakers.Show()

	// 第二套装扮
	suit := decorator.NewSuit()
	tie := decorator.NewTie()
	leatherShoes := decorator.NewLeatherShoes()

	suit.Component.Decorator(p)
	tie.Component.Decorator(suit)
	leatherShoes.Component.Decorator(tie)

	leatherShoes.Show()
}
```

:::

### 案例2

场景：[商场收银程序](./3.md#书中案例实现)再升级，增加复杂的打折策略。

#### UML类图

UML类图新增一个接口`ISale`，用作装饰模式里的`Component`。

装饰模式有一个重要的优点，把类中的装饰功能从类中搬移去除，这样可以简化原有的类。

@startuml
interface ISale {
    +acceptCash(money: number): number
}

class CashSuper {
    +acceptCash(money: number): number
}

ISale <|.. CashSuper
ISale <|.. CashNormal

class CashContext {
    -cs: CashSuper
    +constructor(type: string)
    +getResult(money: number): number
}

CashContext o-- CashSuper

class CashNormal {
    +acceptCash(money: number): number
}

class CashRebate {
    -rebate: number
    +constructor(rebate: number)
    +acceptCash(money: number): number
}

class CashReturn {
    -condition: number
    -result: number
    +constructor(condition: number, moneyReturn: number)
    +acceptCash(money: number): number
}

CashSuper <|-- CashRebate
CashSuper <|-- CashReturn
@enduml


#### 代码实现

::: tabs

@tab TypeScript

::: details 点击查看代码
```ts
interface ISale {
    acceptCash(price: number, num: number): number;
}

class CashSuper implements ISale {
    private _component: ISale;

    public decorate(component: ISale): void {
        this._component = component;
    }

    public acceptCash(price: number, num: number): number {
        let result: number = 0;
        if (this._component) {
            // 若装饰对象存在，则执行装饰的算法运算
            result = this._component.acceptCash(price, num);
        }

        return result;
    }
}

class CashNormal implements ISale {
    // 正常收费，原价返回
    public acceptCash(price: number, num: number): number {
        return price * num;
    }
}

class CashRebate extends CashSuper {
    private moneyRebate: number = 1;

    constructor(moneyRebate: number) {
        super();
        this.moneyRebate = moneyRebate;
    }

    // 计算收费时需要再原价基础上乘以折扣率
    public acceptCash(price: number, num: number): number {
        const result = price * num * this.moneyRebate;
        return super.acceptCash(result, 1);
    }
}

class CashReturn extends CashSuper {
    private moneyCondition: number = 0; // 返利条件
    private moneyReturn: number = 0; // 返利值

    // 返利收费。初始化时需要输入返利条件和返利值
    // 如满300返100，则moneyCondition为300，moneyReturn为100
    constructor(moneyCondition: number, moneyReturn: number) {
        super();
        this.moneyCondition = moneyCondition;
        this.moneyReturn = moneyReturn;
    }

    // 计算收费时，当达到返利条件，就原价减去返利值
    public acceptCash(price: number, num: number): number {
        let result = price * num;
        if (result >= this.moneyCondition) {
            result -= Math.floor(result / this.moneyCondition) * this.moneyReturn;
        }

        return super.acceptCash(result, 1);
    }
}

class CashContext {
    private _cs: ISale;

    public constructor(type: number) {
        switch (type) {
            case 1:
                this._cs = new CashNormal(); // 正常收费
                break;
            case 2:
                this._cs = new CashRebate(0.7); // 打75折
                break;
            case 3:
                this._cs = new CashReturn(300, 100); // 满300减100
                break;
            case 4:
                // 先打8折，再满300减100
                const cn1 = new CashNormal();
                const cr1 = new CashRebate(0.8);
                const cr2 = new CashReturn(300, 100);

                cr1.decorate(cn1); // 用满200返100算法包装基本的原价算法
                cr2.decorate(cr1); // 用打8折算法包装满300返100算法
                this._cs = cr2; // 将包装好的算法组合引用传递给cs对象
                break
            case 5:
                // 先满200返50，再打7折
                const cn2 = new CashNormal();
                const cr3 = new CashReturn(200, 50);
                const cr4 = new CashRebate(0.7);

                cr3.decorate(cn2); // 用满200返50算法包装基本的原价算法
                cr4.decorate(cr3); // 用打7折算法包装满200返50算法
                this._cs = cr4; // 将包装好的算法组合引用传递给cs对象
            default:
                throw new Error('不支持的收费类型');
        }
    }

    public getResult(money: number, num: number): number {
        // 根据收费策略的不同，获得计算结果
        return this._cs.acceptCash(money, num);
    }
}

(async () => {
    const money = 500;
    const type = 4; // 正常开发中 type 可以设定成枚举值
    const cc = new CashContext(type);
    console.log(cc.getResult(money, 1));
})()
```

@tab Golang

::: details 点击查看代码
```go
// decroator_case1.go
package decorator

type iSale interface {
	acceptCash(money float64, num uint32) float64
}

type cashSuper struct {
	component iSale
}

func newCashSuper() *cashSuper {
	return &cashSuper{}
}

func (c *cashSuper) decorator(component iSale) {
	c.component = component
}

func (c *cashSuper) acceptCash(money float64, num uint32) float64 {
	result := 0.0
	if c.component != nil {
		result = c.component.acceptCash(money, num)
	}

	return result
}

type cashNormal struct{}

func newCashNormal() *cashNormal {
	return &cashNormal{}
}

func (c *cashNormal) acceptCash(money float64, num uint32) float64 {
	return money * float64(num)
}

type cashRebate struct {
	moneyRebate float64
	component   *cashSuper
}

func newCashRebate(moneyRebate float64, cashSuper *cashSuper) *cashRebate {
	return &cashRebate{moneyRebate: moneyRebate, component: cashSuper}
}

func (c *cashRebate) acceptCash(money float64, num uint32) float64 {
	result := money * float64(num) * c.moneyRebate
	if c.component != nil {
		result = c.component.acceptCash(result, 1)
	}

	return result
}

type cashReturn struct {
	moneyCondition float64
	moneyReturn    float64
	component      *cashSuper
}

func newCashReturn(moneyCondition, moneyReturn float64, cashSuper *cashSuper) *cashReturn {
	return &cashReturn{moneyCondition: moneyCondition, moneyReturn: moneyReturn, component: cashSuper}
}

func (c *cashReturn) acceptCash(money float64, num uint32) float64 {
	result := money * float64(num)
	if result >= c.moneyCondition {
		result -= float64(int(result/c.moneyCondition)) * c.moneyReturn
	}

	if c.component != nil {
		result = c.component.acceptCash(result, 1)
	}

	return result
}

type CashContext struct {
	cs iSale
}

func NewCashContext(cashType int) *CashContext {
	c := &CashContext{}
	switch cashType {
	case 1:
		c.cs = newCashNormal()
	case 2:
		c.cs = &cashRebate{moneyRebate: 0.75, component: newCashSuper()}
	case 3:
		c.cs = &cashReturn{moneyCondition: 300, moneyReturn: 100, component: newCashSuper()}
	case 4:
		// 先打8折，再满300减100
		cn := newCashNormal()
		cr1 := newCashRebate(0.8, newCashSuper())
		cr2 := newCashReturn(300, 100, newCashSuper())

		cr1.component.decorator(cn)
		cr2.component.decorator(cr1)
		c.cs = cr2
	case 5:
		// 先满200返50，再打7折
		cn := newCashNormal()
		cr1 := newCashReturn(200, 50, newCashSuper())
		cr2 := newCashRebate(0.7, newCashSuper())

		cr1.component.decorator(cn)
		cr2.component.decorator(cr1)
		c.cs = cr2
	default:
		panic("不支持的收费类型")
	}
	return c
}

func (c *CashContext) GetResult(money float64, num uint32) float64 {
	return c.cs.acceptCash(money, num)
}

// main.go
package main

import (
	decorator "design-patterns/04-decorator"
	"fmt"
)

func main() {
	money := 500.0
	cashType := 4
	cc := decorator.NewCashContext(cashType)
	fmt.Println(cc.GetResult(money, 1))
}
```

:::

::: tip

TS/Java与Go Switch语句作用域的区别：
- TS/Java需要显示添加`{}`以区分每一个case的作用域
- Go则不需要，每一个case的作用域是隐式的

:::

## 思考

> 1. 实际的调用链是怎样的？

从第一个案例的输出结果可以看出来：
```
穿着球鞋
穿着大裤衩
穿着大T恤
Tom
穿着皮鞋
穿着领带
穿着西装
Tom
```
最外层的装饰对象`Sneakers`调用`BigTrouser`，`BigTrouser`调用`TShirts`，`TShirts`调用`Person`，`Person`输出`Tom`。
在调用之前，每个装饰对象都做了与自己相关的处理，最后再调用下一个装饰对象。

第二个案例的调用链如下：
```
CashContext
  -> 最外层装饰器 (CashReturn / CashRebate)
      -> 中间层装饰器 (CashReturn / CashRebate)
          -> 基础层组件 (CashNormal)
```

> 2. TypeScript和Golang实现的区别？

- 面向对象实现的方法不同

前文[面向对象基础](./1.md#继承)中提到，TS是基于类的面向对象语言，而Go是基于接口的面向对象语言。

在装饰模式中，TS使用类继承的方式实现，而Go使用接口组合的方式实现，这就导致了Go需要显式在结构体中添加一个`component`字段，而TS则可以直接在类中添加一个`component`字段让子类继承即可。在初始化时，Go也需要显式地传入`component`，而TS则可以直接在子类中调用`super`方法。

不过这也带来一个好处，就是代码的可读性更高，更容易梳理出调用链。

> 3. 实际开发中的应用场景？

装饰模式在实际开发中的应用场景有很多，比如：

- `Express`框架中的中间件
- `Java`中的`IO`流
- `Go`中的`http.Handler`接口

## 总结

装饰模式是一种结构型设计模式，它允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。这种模式的主要优点在于无需创建新子类即可扩展对象的行为，也无需通过继承来覆盖现有方法。

这种模式允许你在新需求出现时可以在不改动现有类的基础上，通过装饰类来扩展现有类的功能，这样可以==节省大把时间==！

同样，装饰模式也有一些缺点，比如装饰类和组件类的接口必须保持一致，这样才能在不影响其他对象的情况下，动态地给一个对象添加一些额外的职责，也就是说，装饰模式的灵活性是以牺牲程序的整体性为代价的，在一开始就需要设计好接口，否则在第一次扩展的时候还得重写接口，这样就得不偿失了。

::: info

封面来源：[Pixiv](https://www.pixiv.net/artworks/119168789) <br>
参考书籍：[《大话设计模式》](http://www.tup.tsinghua.edu.cn/booksCenter/book_09792501.html)

:::