---
title: 简单工厂模式
isOriginal: true
order: 2
cover: https://images.icestream32.cn/images/2024/11/09/1731087479873.jpg
category:
    - 计算机
    - 读书笔记
    - 设计模式
tag:
    - 简单工厂模式
    - UML
    - TypeScript
    - Golang
---

<!-- more -->

## 定义

简单工厂模式（Simple Factory Pattern）：又称为静态工厂方法模式，它属于创建型设计模式。

简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例，其是工厂模式家族中最简单实用的模式。

## UML类图

本人第一次接触UML类图，因此在这里记录一下书中相关定义以及语法含义。

### 介绍

UML（Unified Modeling Language）统一建模语言，是一种用于软件系统分析和设计的标准建模语言。

UML是一种开放的方法，它不仅可以用于软件开发过程中的各个阶段，还可以用于建模非软件系统。

### 抽象类

@startuml
abstract class 动物 {
    +有生命
    +新陈代谢(氧气水)
    +繁殖()
}
@enduml

类图中的斜体字表示抽象类，抽象类不能被实例化，只能被继承。

### 类

@startuml
class 鸟 {
    +羽毛
    +有角质喙没有牙齿
    +下蛋()
}
@enduml

类图分为三层，第一层显示类的名称，第二层显示类的特征，即字段和属性，第三层显示类的操作，即方法或行为。

注意前面的符号，`+`表示public，`-`表示private，`#`表示protected。（这里用plantuml渲染了，后面实际代码会有）

### 接口

@startuml
interface 飞翔 {
    +飞()
}
@enduml

接口图与类图的区别主要是顶端有一个`<<interface>>`标签。

第一行是接口名称，第二行是接口方法。

接口还有另一种表示方法，即棒棒糖表示法，如下：

@startuml
class 唐老鸭 {
    +讲话()
}

唐老鸭 -() 讲人话
@enduml

圆圈旁为接口名称，接口方法在实现类中出现。

### 继承

@startuml
abstract class 动物 {
    +有生命
    +新陈代谢(氧气水)
    +繁殖()
}

class 鸟 {
    +羽毛
    +有角质喙没有牙齿
    +下蛋()
}

动物 <|-- 鸟
@enduml

继承关系用空心三角形+实线表示。

### 实现

@startuml
interface 飞翔 {
    +飞()
}

class 大雁 {
    +下蛋()
    +飞()
}

大雁 ..|> 飞翔
@enduml

实现关系用空心三角形+虚线表示。

### 关联

@startuml
left to right direction
class 气候 {

}

class 企鹅 {
    +下蛋()
}

企鹅 --> 气候
@enduml

关联关系用实线箭头来表示。

::: tabs

@tab TypeScript

```ts
class 气候 {

}

class 企鹅 {
    public 气候
}
```

@tab Golang

```go
type 气候 struct {
}

type 企鹅 struct {
    气候
}
```

:::

### 聚合

@startuml
left to right direction
class 雁群 {
    +V型飞行()
    +一字飞行()
}

class 大雁 {
    +下蛋()
    +飞()
}

雁群 o-- 大雁
@enduml

聚合表示一种弱的'拥有'关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分。

聚合关系用空心菱形+实线箭头表示。

::: tabs

@tab TypeScript

```ts
class 雁群 {
    public 大雁[]
}

class 大雁 {
}
```

@tab Golang

```go
type 雁群 struct {
    大雁 []大雁
}

type 大雁 struct {
}
```

:::

### 组合

@startuml
left to right direction
class 翅膀 {

}

class 鸟 {
    +羽毛
    +有角质喙没有牙齿
    +下蛋()
}

鸟 *-- 翅膀
@enduml

组合表示一种强的'拥有'关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样。

组合关系用实心菱形+实线箭头表示。

::: tabs

@tab TypeScript

```ts
class 翅膀 {

}

class 鸟 {
    public 翅膀
}
```

@tab Golang

```go
type 翅膀 struct {
}

type 鸟 struct {
    翅膀
}
```

:::

### 依赖

@startuml
left to right direction
class 动物 {
    +有生命
    +新陈代谢(氧气水)
    +繁殖()
}

class 氧气 {}

class 水 {}

动物 ..> 氧气
动物 ..> 水
@enduml

依赖关系用虚线箭头表示。

::: tabs

@tab TypeScript

```ts
class 氧气 {

}

class 水 {

}

class 动物 {
    public 呼吸(氧气, 水) {}
}
```

@tab Golang

```go
type 氧气 struct {
}

type 水 struct {
}

type 动物 struct {
}

func (a *动物) 呼吸(氧气, 水) {}
```

:::

## plantuml语法

```plantuml
@startuml // 开始
abstract class 动物 { // 抽象类
    +有生命 // 特征 +表示public
    +新陈代谢(氧气水)
    +繁殖()
}

class 鸟 { // 类
    +羽毛
    +有角质喙没有牙齿
    +下蛋() // 操作
}

动物 <|-- 鸟 // 继承

interface 飞翔 { // 接口
    +飞()
}

class 大雁 { // 类
    +下蛋()
    +飞()
}

大雁 ..|> 飞翔 // 实现

class 气候 { // 类

}

class 企鹅 { // 类
    +下蛋()
}

企鹅 --> 气候 // 关联

class 雁群 { // 类
    +V型飞行()
    +一字飞行()
}

雁群 o-- 大雁 // 聚合

class 翅膀 { // 类

}

鸟 *-- 翅膀 // 组合

class 动物 { // 类
    +有生命
    +新陈代谢(氧气水)
    +繁殖()
}

class 氧气 { // 类

}

class 水 { // 类

}

动物 ..> 氧气 // 依赖
@enduml // 结束
```

## 书中案例实现

场景：使用面向对象的方法实现一个计算器，可以进行加减乘除四则运算。

UML类图如下：

@startuml
interface Calculator {
    +getResult(): number
}

class Add {
    -num1: number
    -num2: number
    +getResult(): number
}

class Sub {
    -num1: number
    -num2: number
    +getResult(): number
}

class Mul {
    -num1: number
    -num2: number
    +getResult(): number
}

class Div {
    -num1: number
    -num2: number
    +getResult(): number
}

class OperationFactory {
    +createOperation(operator: string, num1: number, num2: number): Calculator
}

Add ..|> Calculator
Sub ..|> Calculator
Mul ..|> Calculator
Div ..|> Calculator

Calculator <.. OperationFactory
@enduml

::: tip

之后的UML类图我都是按照TypeScript的语法来写，因为TypeScript面向对象的特性更加丰富，更容易理解。

:::

::: tabs

@tab TypeScript

::: details 点击查看详细代码

```ts
import readline from 'readline/promises'

// 计算器接口，用于获取计算结果
interface ICalculator {
    getResult(): number;
}

// 加法
class Add implements ICalculator {
    private num1: number;
    private num2: number;

    constructor(num1: number, num2: number) {
        this.num1 = num1;
        this.num2 = num2;
    }

    getResult(): number {
        return this.num1 + this.num2;
    }
}

// 减法
class Sub implements ICalculator {
    private num1: number;
    private num2: number;

    constructor(num1: number, num2: number) {
        this.num1 = num1;
        this.num2 = num2;
    }

    getResult(): number {
        return this.num1 - this.num2;
    }
}

// 乘法
class Mul implements ICalculator {
    private num1: number;
    private num2: number;

    constructor(num1: number, num2: number) {
        this.num1 = num1;
        this.num2 = num2;
    }

    getResult(): number {
        return this.num1 * this.num2;
    }
}

// 除法
class Div implements ICalculator {
    private num1: number;
    private num2: number;

    constructor(num1: number, num2: number) {
        this.num1 = num1;
        this.num2 = num2;
    }

    getResult(): number {
        if (this.num2 === 0) {
            throw new Error('除数不能为0');
        }
        return this.num1 / this.num2;
    }
}

// 处理结果
class ICalculatorFacotory {
    public static createOperator(num1: number, num2: number, operator: string): ICalculator {
        switch (operator) {
            case '+':
                return new Add(num1, num2);
            case '-':
                return new Sub(num1, num2);
            case '*':
                return new Mul(num1, num2);
            case '/':
                return new Div(num1, num2);
            default:
                throw new Error('运算符错误');
        }
    }
}

// 运行
(async () => {

    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    const num1 = await rl.question('请输入第一个数字: ');
    const num2 = await rl.question('请输入第二个数字: ');
    const operator = await rl.question('请输入运算符: ');

    rl.close();

    const calculator = CalculatorFacotory.createOperator(Number(num1), Number(num2), operator);
    const result = calculator.getResult();

    console.log(`计算结果: ${result}`);
})()
```

@tab Golang

::: details 点击查看详细代码

```go
// simple_factory.go
package simple_factory

import "fmt"

type Caculator interface {
	GetResult() float64
}

type Add struct {
	NumberA float64
	NumberB float64
}

func (a *Add) GetResult() float64 {
	return a.NumberA + a.NumberB
}

type Sub struct {
	NumberA float64
	NumberB float64
}

func (s *Sub) GetResult() float64 {
	return s.NumberA - s.NumberB
}

type Mul struct {
	NumberA float64
	NumberB float64
}

func (m *Mul) GetResult() float64 {
	return m.NumberA * m.NumberB
}

type Div struct {
	NumberA float64
	NumberB float64
}

func (d *Div) GetResult() float64 {
	if d.NumberB == 0 {
		panic("除数不能为0")
	}
	return d.NumberA / d.NumberB
}

func GetInput() (float64, float64, string) {
	var numberA, numberB float64
	var operator string
	fmt.Println("请输入数字A:")
	fmt.Scanln(&numberA)
	fmt.Println("请输入数字B:")
	fmt.Scanln(&numberB)
	fmt.Println("请输入运算符:")
	fmt.Scanln(&operator)

	return numberA, numberB, operator
}

func CreateOperation(numberA, numberB float64, operator string) Caculator {
	switch operator {
	case "+":
		return &Add{NumberA: numberA, NumberB: numberB}
	case "-":
		return &Sub{NumberA: numberA, NumberB: numberB}
	case "*":
		return &Mul{NumberA: numberA, NumberB: numberB}
	case "/":
		return &Div{NumberA: numberA, NumberB: numberB}
	default:
		panic("运算符错误")
	}
}

// main.go
package main

import (
	simple_factory "design-patterns/02-simpile_factory"
	"fmt"
)

func main() {
	numberA, numberB, operator := simple_factory.GetInput()

	caculator := simple_factory.CreateOperation(numberA, numberB, operator)
	fmt.Println(caculator.GetResult())
}
```

::: tip

- go test命令不支持测试交互式程序，所以这里没有写测试用例，而是直接在main函数中通过`go run main.go`调用。

- go 是半面向对象半面向过程的语言，所以这里工厂方法没有写在类中，而是写在了包中。

:::

## 总结

简单工厂模式是一种创建型设计模式，它提供了一个创建对象实例的方法，而不需要指定具体的类。

简单工厂模式的优点是可以根据条件创建不同的对象，客户端不需要知道具体的类，只需要知道工厂类即可。

::: info

封面来源：[Pixiv](https://www.pixiv.net) <br>
参考书籍：[《大话设计模式》](http://www.tup.tsinghua.edu.cn/booksCenter/book_09792501.html)

:::
