---
title: 状态模式
isOriginal: true
order: 12
cover: https://images.icestream32.cn/images/2025/02/10/112173308_p0_master1200.jpg
category:
    - 计算机
    - 读书笔记
    - 设计模式
tag:
    - 状态模式
    - TypeScript
    - Golang
---

状态模式（State Pattern），当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。

<!-- more -->

## 书中案例实现

情景：从早到晚工作的状态切换

### UML 类图

@startuml
left to right direction 

interface State {
    +writeProgram(work: Work): void
}

class ForenoonState {
    +writeProgram(work: Work): void
}

class NoonState {
    +writeProgram(work: Work): void
}

class AfternoonState {
    +writeProgram(work: Work): void
}

class EveningState {
    +writeProgram(work: Work): void
}

class RestState {
    +writeProgram(work: Work): void
}

class SleepingState {
    +writeProgram(work: Work): void
}

class Work {
    -state: State
    +hour: number
    +finish: boolean
    +setState(state: State): void
    +writeProgram(): void
}

State <|.. ForenoonState
State <|.. NoonState
State <|.. AfternoonState
State <|.. EveningState
State <|.. RestState
State <|.. SleepingState

Work o-- State
Work <.. State
@enduml

## 代码实现

::: tabs

@tab TypeScript

定义一个`State`状态接口，包含一个`writeProgram`方法，接受一个`Work`对象作为参数。

```ts
// 状态接口
interface State {
    writeProgram(work: Work): void;
}
```

上午和中午工作状态类：

```ts
// 上午工作状态
class ForenoonState implements State {

    public writeProgram(work: Work): void {

        if (work.getHour() < 12) {
            console.log(`当前时间：${work.getHour()}点 上午工作，精神百倍`);
        } else {
            work.setState(new NoonState()); // 超过12点，转入中午工作状态
            work.writeProgram();
        }
    }
}

// 中午工作状态
class NoonState implements State {

    public writeProgram(work: Work): void {

        if (work.getHour() < 13) {
            console.log(`当前时间：${work.getHour()}点 饿了，午饭；犯困，午休`);
        } else {
            work.setState(new AfternoonState()); // 超过13点转入下午工作状态
            work.writeProgram();
        }
    }
}
```

下午和晚间工作状态类：

```ts
// 下午工作状态
class AfternoonState implements State {

    public writeProgram(work: Work): void {

        if (work.getHour() < 17) {
            console.log(`当前时间：${work.getHour()}点 下午状态还不错，继续努力`);
        } else {
            work.setState(new EveningState()); // 超过17点，转入晚间工作状态
            work.writeProgram();
        }
    }
}

// 晚间工作状态
class EveningState implements State {

    public writeProgram(work: Work): void {

        if (work.getWorkFinished()) {
            work.setState(new RestState()); // 如果工作完成，转入下班状态
            work.writeProgram();
        } else {
            if (work.getHour() < 21) {
                console.log(`当前时间：${work.getHour()}点 加班哦，疲累之极`);
            } else {
                work.setState(new SleepingState()); // 超过21点，转入睡眠工作状态
                work.writeProgram();
            }
        }
    }
}
```

睡眠状态和下班休息状态类：

```ts
// 下班休息状态
class RestState implements State {

    public writeProgram(work: Work): void {
        console.log(`当前时间：${work.getHour()}点 下班回家了`);
    }
}

// 睡眠状态
class SleepingState implements State {

    public writeProgram(work: Work): void {
        console.log(`当前时间：${work.getHour()}点 不行了，睡着了`);
    }
}
```

工作类：

```ts
// 工作类
class Work {
    private current: State;

    // 钟点属性，状态转换的依据
    private hour: number;

    // 工作完成与否属性，是否能下班的依据
    private workFinished: boolean;

    constructor() {
        // 初始化状态
        this.current = new ForenoonState();
    }

    public setState(state: State): void {
        // 设置当前状态
        this.current = state
    }

    public getHour(): number {
        return this.hour;
    }

    public setHour(value: number): void {
        this.hour = value;
    }

    public writeProgram() {
        // 显示当前状态，并切换下一个状态
        this.current.writeProgram(this);
    }

    public getWorkFinished(): boolean {
        return this.workFinished;
    }

    public setWorkFinished(value: boolean): void {
        this.workFinished = value;
    }
}
```

客户端代码：

```ts
// 客户端代码
(async () => {
    const emergencyProjects = new Work();
    emergencyProjects.setHour(9);
    emergencyProjects.writeProgram();

    emergencyProjects.setHour(10);
    emergencyProjects.writeProgram();

    emergencyProjects.setHour(12);
    emergencyProjects.writeProgram();

    emergencyProjects.setHour(13);
    emergencyProjects.writeProgram();

    emergencyProjects.setHour(14);
    emergencyProjects.writeProgram();

    emergencyProjects.setHour(17);
    emergencyProjects.writeProgram();

    emergencyProjects.setWorkFinished(true);
    emergencyProjects.writeProgram();

    emergencyProjects.setHour(19);
    emergencyProjects.writeProgram();

    emergencyProjects.setHour(22);
    emergencyProjects.writeProgram();
})();
```

输出如下：

```
当前时间：9点 上午工作，精神百倍
当前时间：10点 上午工作，精神百倍
当前时间：12点 饿了，午饭；犯困，午休
当前时间：13点 下午状态还不错，继续努力
当前时间：14点 下午状态还不错，继续努力
当前时间：17点 加班哦，疲累之极
当前时间：17点 下班回家了
当前时间：19点 下班回家了
当前时间：22点 下班回家了
```

@tab Golang

定义一个`State`状态接口，包含一个`writeProgram`方法，接受一个`Work`对象作为参数。

```go
// State 状态接口
type State interface {
	writeProgram(work *Work)
}
```

上午和中午工作状态结构体：

```go
// Forenoon 上午工作状态
type Forenoon struct{}

func (f *Forenoon) writeProgram(work *Work) {
	if work.Hour < 12 {
		fmt.Printf("当前时间：%d点 上午工作，精神百倍\n", work.Hour)
	} else {
		work.SetState(&Noon{})
		work.WriteProgram()
	}
}

// Noon 中午工作状态
type Noon struct{}

func (n *Noon) writeProgram(work *Work) {
	if work.Hour < 13 {
		fmt.Printf("当前时间：%d点 饿了，午饭；犯困，午休\n", work.Hour)
	} else {
		work.SetState(&Afternoon{})
		work.WriteProgram()
	}
}
```

下午和晚间工作状态结构体：

```go
// Afternoon 下午工作状态
type Afternoon struct{}

func (a *Afternoon) writeProgram(work *Work) {
	if work.Hour < 17 {
		fmt.Printf("当前时间：%d点 下午状态还不错，继续努力\n", work.Hour)
	} else {
		work.SetState(&Evening{})
		work.WriteProgram()
	}
}

// Evening 晚间工作状态
type Evening struct{}

func (e *Evening) writeProgram(work *Work) {
	if work.TaskFinished {
		work.SetState(&Rest{})
		work.WriteProgram()
	} else {
		if work.Hour < 21 {
			fmt.Printf("当前时间：%d点 加班哦，疲累之极\n", work.Hour)
		} else {
			work.SetState(&Sleeping{})
			work.WriteProgram()
		}
	}
}
```

睡眠状态和下班休息状态结构体：

```go
// Sleeping 睡眠状态
type Sleeping struct{}

func (s *Sleeping) writeProgram(work *Work) {
	fmt.Printf("当前时间：%d点 不行了，睡着了\n", work.Hour)
}

// Rest 下班休息状态
type Rest struct{}

func (r *Rest) writeProgram(work *Work) {
	fmt.Printf("当前时间：%d点 下班回家了\n", work.Hour)
}
```

工作结构体：

```go
// Work 工作类
type Work struct {
	Hour         int
	TaskFinished bool
	state        State
}

// NewWork 实例化工作类
func NewWork() *Work {
	return &Work{state: &Forenoon{}}
}

// SetState 设置工作状态
func (w *Work) SetState(state State) {
	w.state = state
}

// WriteProgram 写程序
func (w *Work) WriteProgram() {
	w.state.writeProgram(w)
}
```

客户端代码：

```ts
// 客户端代码
func main() {
	emergencyProjects := state.NewWork()

	emergencyProjects.Hour = 9
	emergencyProjects.WriteProgram()

	emergencyProjects.Hour = 10
	emergencyProjects.WriteProgram()

	emergencyProjects.Hour = 12
	emergencyProjects.WriteProgram()

	emergencyProjects.Hour = 13
	emergencyProjects.WriteProgram()

	emergencyProjects.Hour = 14
	emergencyProjects.WriteProgram()

	emergencyProjects.Hour = 17
	emergencyProjects.WriteProgram()

	emergencyProjects.TaskFinished = false
	emergencyProjects.Hour = 19
	emergencyProjects.WriteProgram()

	emergencyProjects.Hour = 22
	emergencyProjects.WriteProgram()
}
```

输出如下：

```
当前时间：9点 上午工作，精神百倍
当前时间：10点 上午工作，精神百倍
当前时间：12点 饿了，午饭；犯困，午休
当前时间：13点 下午状态还不错，继续努力
当前时间：14点 下午状态还不错，继续努力
当前时间：17点 加班哦，疲累之极
当前时间：17点 下班回家了
当前时间：19点 下班回家了
当前时间：22点 下班回家了
```

:::

## 思考

> 1. 为什么要使用状态模式？

笑死，上一段原先的代码就知道一堆嵌套if-else的痛苦了

```go
type Work struct {
    Hour         int
    TaskFinished bool
}

func (w *Work) WriteProgram() {
    if w.Hour < 12 {
        fmt.Printf("当前时间：%d点 上午工作，精神百倍\n", w.Hour)
    } else if w.Hour < 13 {
        fmt.Printf("当前时间：%d点 饿了，午饭；犯困，午休\n", w.Hour)
    } else if w.Hour < 17 {
        fmt.Printf("当前时间：%d点 下午状态还不错，继续努力\n", w.Hour)
    } else {
        if w.TaskFinished {
            fmt.Printf("当前时间：%d点 下班回家了\n", w.Hour)
        } else {
            if w.Hour < 21 {
                fmt.Printf("当前时间：%d点 加班哦，疲累之极\n", w.Hour)
            } else {
                fmt.Printf("当前时间：%d点 不行了，睡着了\n", w.Hour)
            }
        }
    }
}
```

层层嵌套的if-else语句会使代码的可读性特别差，因此状态模式就是为了解决这个问题而生的。

> 2. 状态模式的好处？

状态模式的好处是将与特定状态相关的行为局部化，并且将不同状态的行为分割开来，满足“单一职责原则”，其目的是为了消除庞大的分支语句。

> 3. 如何使用状态模式？

- 定义一个状态接口，接口中定义一个所有状态共有的方法。

- 实现具体的状态类，每个状态类实现状态接口中的方法，同时根据具体的业务逻辑进行相应的处理，或者切换到下一个状态。

举例：前端传来一个请求，请求体中有一个字段是`code`字段，你需要判断这个`code`字段是属于A、B、C或者D，从而进行对应的处理。

解决方案：

- 定义一个状态接口，接口中定义一个`handle`方法。

- 实现具体的状态类，每个状态类实现状态接口中的`handle`方法，根据`code`字段的值进行相应的处理，如果`code`字段的值是A，那么就执行A状态的`handle`方法，以此类推。

代码实现：

```ts
// 状态接口
interface State {
    handle(code: string): void;
}

// A状态 其余同理
class AState implements State {
    public handle(code: string): void {
        if (code === 'A对应的值') {
            console.log('执行A状态的处理逻辑');
        }
    }
}

// 判断类
class Judge {
    private state: State;

    constructor() {
        this.state = new AState();
    }

    public handle(code: string): void {
        this.state.handle(code);
    }
}

// 客户端代码
const judge = new Judge(new AState());

judge.handle('A对应的值');
judge.handle('B对应的值');
judge.handle('C对应的值');
judge.handle('D对应的值');
```

::: info

封面来源：[Pixiv](https://www.pixiv.net/artworks/112173308) <br>
参考书籍：[《大话设计模式》](http://www.tup.tsinghua.edu.cn/booksCenter/book_09792501.html)

:::
