---
title: 第2章 竞争条件与数据竞争
order: 2
cover: https://images.icestream32.cn/images/2025/01/07/120498537_p0_master1200.jpg
category:
    - 计算机
    - 读书笔记
    - 并发编程
tag:
    - Golang
    - 竞争条件
    - 数据竞争
---

第2章开篇就讲了这两个的定义以及具体的例子，以下是我的一些总结：

<!-- more -->

## 定义

- **竞争条件**：

指的是在多线程环境中，由于操作顺序的不确定性导致的程序执行结果的不确定性。
比如说如果两个线程同时对一个变量进行读/写操作，那么它们的执行顺序将会对最终的结果产生影响。
外部时序或排序的非确定性会产生竞争条件，典型的示例包括上下文切换、操作系统中断、多处理器上的内存操作和硬件中断等。
竞争条件有时候难以避免，因为在很多情况下我们无法精确控制goroutine的执行顺序，但是我们可以通过一些手段来减少竞争条件的发生。

- **数据竞争**：

指的是多线程环境中，由于操作顺序的不确定性导致的数据不一致问题。
比如说如果两个线程同时对一个变量进行读/写操作，并且没有使用任何同步原语，那么它们的操作条件将会导致数据的不一致，这就是数据竞争。

晁老师指出，竞争条件和数据竞争的区别在于：前者是一种状态，而后者是一种问题。

本人从解决的思路出发，是这么理解的：

> 竞争条件问题的根本在于**程序执行顺序的不确定性**，因此我们可以通过同步机制、原子操作、设计调整等手段来减少竞争条件的发生。

> 数据竞争问题的根本在于**对共享数据的并发访问**，因此我们可以通过互斥锁、原子操作、线程本地存储、不可变数据等手段来避免数据竞争。


| 方面 | 	竞争条件 |	数据竞争 |
| --- | --- | --- |
| 核心问题 |	执行顺序不确定导致结果异常|	并发访问共享数据导致数据不一致|
| 解决重点 |	控制执行顺序 |	保护共享数据 |
| 典型工具 |	锁、信号量、条件变量 |	锁、原子操作、不可变数据 |
| 示例场景 |	多个线程竞争同一资源，顺序影响结果 |	多个线程同时读写同一变量 |

## 示例

书中给出了一个简单的案例——银行转账，来说明竞争条件和数据竞争的区别：

### 公共代码

```go
type Account struct {
    Balance int64 // 余额
    InTx   bool  // 是否在交易中
}
```

### 没有考虑竞争条件和数据竞争的转账实现

```go
// 转账
// amount: 转账金额
// accountFrom: 转出账户
// accountTo: 转入账户
func transfer1(amount int64, accountFrom, accountTo *Account) bool {

	// 检查余额是否小于转账金额
	if accountFrom.Balance < amount {
		return false
	}
	// 目标账户的余额加上转账金额
	accountTo.Balance += amount
    time.Sleep(time.Millisecond) // 模拟转账过程网络延迟
	// 转出账户的余额减去转账金额
	accountFrom.Balance -= amount

	return true
}
```

源账户有100万元，如果两个线程同时转账100万元，那么最终的结果可能是源账户的余额为-100万元，目标账户的余额为200万元，这就是竞争条件问题。

两个目标账户都有100万元，银行莫名其妙损失了100万元，这就是数据竞争问题。

测试代码如下：

```go
func TestTransfer1(t *testing.T) {
	accountFrom := &Account{
		Balance: 100,
	}
	accountTo1 := &Account{
		Balance: 0,
	}
	accountTo2 := &Account{
		Balance: 0,
	}

	// 同时向两个用户转账100
	amount := int64(100)
	var wg sync.WaitGroup
	wg.Add(2)

	go func() {
		defer wg.Done()
		transfer1(amount, accountFrom, accountTo1)
	}()

	go func() {
		defer wg.Done()
		transfer1(amount, accountFrom, accountTo2)
	}()

	wg.Wait()

	// 输出转账后的余额
	fmt.Printf("AccountFrom: %d\n", accountFrom.Balance)
	fmt.Printf("AccountTo1: %d\n", accountTo1.Balance)
	fmt.Printf("AccountTo2: %d\n", accountTo2.Balance)
}
```

::: tip

- 这里的`WaitGroup`是一个同步原语，用于等待两个goroutine执行完毕后再继续执行主线程。我们会在之后的章节中讲到。
- 通过调整`time.Sleep`的时间，我们可以模拟不同的网络延迟，从而观察数据竞争问题。

:::

### 考虑数据竞争但不考虑竞争条件的转账实现

```go
func transfer2(amount int64, accountFrom, accountTo *Account) bool {

	bal := atomic.LoadInt64(&accountFrom.Balance)
	time.Sleep(time.Second)
	// 检查余额是否小于转账金额
	if bal < amount {
		return false
	}
	atomic.AddInt64(&accountTo.Balance, amount)    // 原子操作-新增
	atomic.AddInt64(&accountFrom.Balance, -amount) // 原子操作-减少

	return true
}
```

`atomic`包提供了一些原子操作，可以保证在多线程环境下的数据安全，这里使用了`atomic.LoadInt64`和`atomic.AddInt64`来保证数据的一致性，确保数据没有竞争问题。
但是这里的`time.Sleep`会导致竞争条件问题，因为它会导致两个线程的执行顺序不确定，当g1和g2同时执行的时候，它们都认为源账户的余额为100，那么在转账过后，最终源账户的余额就会变成-20，这对于银行来说是不合理的。


### 考虑竞争条件和数据竞争的转账实现

```go
var mutex sync.Mutex

func transfer3(amount int64, accountFrom, accountTo *Account) bool {

	mutex.Lock()
	defer mutex.Unlock()

	bal := atomic.LoadInt64(&accountFrom.Balance)
	if bal < amount {
		return false
	}

	atomic.AddInt64(&accountTo.Balance, amount)
	atomic.AddInt64(&accountFrom.Balance, -amount)

	return true
}
```

这里使用了`sync.Mutex`来解决竞争条件问题，其中`Lock`和`Unlock`分别用于加锁和解锁，确保了两个线程不会同时访问共享资源。测试代码也展示在10000次循环中，转账的结果也能是正确的。

```go
func TestTransfer3(t *testing.T) {

	// 同时向两个用户转账100

	const N = 10000

	for i := 0; i < N; i++ {
		var wg sync.WaitGroup
		wg.Add(2)

		accountFrom := &Account{
			Balance: 100,
		}
		accountTo1 := &Account{
			Balance: 0,
		}
		accountTo2 := &Account{
			Balance: 0,
		}

		go func() {
			defer wg.Done()
			transfer3(int64(100), accountFrom, accountTo1)
		}()

		go func() {
			defer wg.Done()
			transfer3(int64(100), accountFrom, accountTo2)
		}()

		wg.Wait()

		if accountFrom.Balance < 0 {
			t.Errorf("accountFrom.Balance = %d", accountFrom.Balance)
			t.Fail()
		}

		if accountTo1.Balance+accountTo2.Balance != 100 {
			t.Errorf("accountTo1.Balance = %d, accountTo2.Balance = %d", accountTo1.Balance, accountTo2.Balance)
			t.Fail()
		}
	}
}
```

::: tip

`sync.Mutex`不能作为局部变量，因为每次调用`transfer3`函数都会创建一个新的`sync.Mutex`，这样互斥锁就无法正常工作。因此我们需要将`sync.Mutex`定义为全局变量。

:::

### 不考虑竞争条件但考虑数据竞争的转账实现

```go
var mutex sync.Mutex

func transfer4(amount int64, accountFrom, accountTo *Account) bool {

	accountFrom.InTx = true
	accountTo.InTx = true

	defer func() {
		accountFrom.InTx = false
		accountTo.InTx = false
	}()

	mutex.Lock()
	defer mutex.Unlock()

	bal := atomic.LoadInt64(&accountFrom.Balance)
	if bal < amount {
		return false
	}

	atomic.AddInt64(&accountTo.Balance, amount)
	atomic.AddInt64(&accountFrom.Balance, -amount)

	return true
}
```

在这个例子中，InTx表示这个账户在事务中。多线程操作时，可能会同时修改这个变量，但是修改这个变量对实际业务没有什么影响，因此这个函数依然不会导致超额转账的竞争条件问题，只是存在访问InTx的数据竞争问题。

## 总结

上面的例子展示了竞争条件和数据竞争的区别，以下是表格图：

|  | 数据竞争 | 不存在数据竞争 |
| --- | --- | --- |
| 存在竞争条件 | transfer1 | transfer2 |
| 不存在竞争条件 | transfer4 | transfer3 |

在实际开发中，为了解决这类问题，各语言都提供了一些同步原语来解决这些问题，在之后的章节中，我们也会学习到Go语言中的一些同步原语。

::: info

封面来源: [Pixiv](https://www.pixiv.net/artworks/120498537) <br>
参考资料: [《深入理解Go并发编程》](https://item.jd.com/14283252.html)

:::