---
title: 第1章 Go并发编程和调度器
order: 1
cover: https://images.icestream32.cn/images/2025/01/07/108461210_p0_master1200.md.jpg
category:
    - 计算机
    - 读书笔记
    - 并发编程
tag:
    - Go
    - 基准测试
---

第1章讲到了一些并发编程以及Go实现的基本概念，主要是为了让读者对Go并发编程有一个基本的认识。

<!-- more -->

## 并发执行的速度不一定比串行快

在这一章中，我认为印象比较深刻的是“并发执行的速度不一定比串行快”这一例子，晁老师通过快速排序的例子来说明这一点。在并发执行快速排序中，频繁地创建和销毁goroutine会导致性能下降，晁老师通过时间戳相减得出的运行时间来佐证这一点。正好我之前在学习Go语言的时候有了解过`testing`包中的`Benchmark`测试，同样也可以通过这个测试来验证这一点。

首先是三个不同方式实现快速排序的源代码：

- 公共代码

```go
func partition(arr []int, low, high int) int {

	pivot := arr[high]
	i := low - 1

	for j := low; j < high; j++ {
		if arr[j] < pivot {
			i++
			arr[i], arr[j] = arr[j], arr[i]
		}
	}
	arr[i+1], arr[high] = arr[high], arr[i+1]

	return i + 1
}
```

- 串行实现

```go
func quickSort(arr []int, low, high int) {

	if low < high {
		pi := partition(arr, low, high)
		quickSort(arr, low, pi-1)
		quickSort(arr, pi+1, high)
	}
}
```

- 并发实现

```go
func quickSort_go(arr []int, low, high int, done chan struct{}) {

	if low >= high {
		done <- struct{}{}
		return
	}

	pi := partition(arr, low, high)
	childDone := make(chan struct{}, 2)
	go quickSort_go(arr, low, pi-1, childDone)
	go quickSort_go(arr, pi+1, high, childDone)
	<-childDone
	<-childDone
	done <- struct{}{}
}
```

- 串行+并发实现

```go
func QuickSort_go2(arr []int, low, high int, done chan struct{}, depth int) {

	if low >= high {
		done <- struct{}{}
		return
	}
	depth--
	pi := Partition(arr, low, high)

	if depth > 0 {
		childDone := make(chan struct{})

		go QuickSort_go2(arr, low, pi-1, childDone, depth-1)
		go QuickSort_go2(arr, pi+1, high, childDone, depth-1)

		<-childDone
		<-childDone
	} else {
		QuickSort(arr, low, pi-1)
		QuickSort(arr, pi+1, high)
	}

	done <- struct{}{}
}
```

然后是基准测试代码：

- 公共代码

```go
const N = 10000000

// 生成随机数组
func generateRandomArray() []int {

	arr := make([]int, N)
	for i := 0; i < N; i++ {
		arr[i] = rand.Intn(N * 100)
	}
	return arr
}
```

- 串行基准测试

```go
func BenchmarkQuickSort(b *testing.B) {

	arr := generateRandomArray()
	for i := 0; i < b.N; i++ {
		arrCopy := make([]int, len(arr))
		copy(arrCopy, arr)

		// 执行排序
		b.StartTimer()
		QuickSort(arrCopy, 0, len(arrCopy)-1)
		b.StopTimer()
	}

	// 获取总耗时（毫秒）
	elapsed := b.Elapsed().Milliseconds()
	// 输出平均耗时
	b.Logf("Average elapsed time: %d ms", elapsed/int64(b.N))
}
```

运行结果如下：
```shell
Running tool: C:\Program Files\Go\bin\go.exe test -benchmem -run=^$ -bench ^BenchmarkQuickSort$ concurrency-in-go/part01

goos: windows
goarch: amd64
pkg: concurrency-in-go/part01
cpu: AMD Ryzen 9 7950X3D 16-Core Processor
=== RUN   BenchmarkQuickSort
BenchmarkQuickSort
    c:\Users\icestream32\Desktop\projects\go\src\concurrency-in-go\part01\part01_test.go:36: Average elapsed time: 691 ms
    c:\Users\icestream32\Desktop\projects\go\src\concurrency-in-go\part01\part01_test.go:36: Average elapsed time: 628 ms
BenchmarkQuickSort-32
       2         628587300 ns/op        80005608 B/op          4 allocs/op
PASS
ok      concurrency-in-go/part01        7.305s
```

- 并发基准测试

```go
func BenchmarkQuickSort_go(b *testing.B) {

	arr := generateRandomArray()

	for i := 0; i < b.N; i++ {
		arrCopy := make([]int, len(arr))
		copy(arrCopy, arr)

		// 执行排序
		done := make(chan struct{})
		b.StartTimer()
		go QuickSort_go(arrCopy, 0, len(arrCopy)-1, done)
		<-done
		b.StopTimer()
	}

	// 获取总耗时（秒）
	elapsed := b.Elapsed().Seconds()
	// 输出平均耗时
	b.Logf("Average elapsed time: %f s", elapsed/float64(b.N))
}
```

运行结果如下：

```shell
Running tool: C:\Program Files\Go\bin\go.exe test -benchmem -run=^$ -bench ^BenchmarkQuickSort_go$ concurrency-in-go/part01

goos: windows
goarch: amd64
pkg: concurrency-in-go/part01
cpu: AMD Ryzen 9 7950X3D 16-Core Processor
=== RUN   BenchmarkQuickSort_go
BenchmarkQuickSort_go
    c:\Users\icestream32\Desktop\projects\go\src\concurrency-in-go\part01\part01_test.go:58: Average elapsed time: 2.481385 s
BenchmarkQuickSort_go-32               1        2481385000 ns/op        2034177928 B/op 20847116 allocs/op
PASS
ok      concurrency-in-go/part01        8.038s
```

> 注意：不受限制的并发测试会占用大量系统资源，因此慎重运行，以图为证。。。

![image-20250111184524911](https://images.icestream32.cn/images/2025/01/11/image-20250111184524911.png)

- 串行+并发基准测试

```go
func BenchmarkQuickSort_go2(b *testing.B) {

    arr := generateRandomArray()

    for i := 0; i < b.N; i++ {
        arrCopy := make([]int, len(arr))
        copy(arrCopy, arr)

        // 执行排序
        done := make(chan struct{})
        b.StartTimer()
        go QuickSort_go2(arrCopy, 0, len(arrCopy)-1, done, 2)
        <-done
        b.StopTimer()
    }

    // 获取总耗时（秒）
    elapsed := b.Elapsed().Seconds()
    // 输出平均耗时
    b.Logf("Average elapsed time: %f s", elapsed/float64(b.N))
}
```

运行结果如下：

```shell
Running tool: C:\Program Files\Go\bin\go.exe test -benchmem -run=^$ -bench ^BenchmarkQuickSort_go2$ concurrency-in-go/part01

goos: windows
goarch: amd64
pkg: concurrency-in-go/part01
cpu: AMD Ryzen 9 7950X3D 16-Core Processor
=== RUN   BenchmarkQuickSort_go2
BenchmarkQuickSort_go2
    c:\Users\icestream32\Desktop\projects\go\src\concurrency-in-go\part01\part01_test.go:80: Average elapsed time: 194 ms
    c:\Users\icestream32\Desktop\projects\go\src\concurrency-in-go\part01\part01_test.go:80: Average elapsed time: 183 ms
BenchmarkQuickSort_go2-32              6         183314200 ns/op        26763218 B/op        864 allocs/op
PASS
ok      concurrency-in-go/part01        6.636s
```

比较三者结果可以看到：

- 串行实现的平均耗时为 628 ms
- 并发实现的平均耗时为 2.481385 s
- 串行+并发实现的平均耗时为 183 ms

可以看到，串行+并发实现的平均耗时最短，而并发实现的平均耗时最长，这也验证了晁老师在书中所说的“并发执行的速度不一定比串行快”这一观点。

同时，Go testing包中的基准测试使用起来也非常方便，可以通过`go test -bench=.`来运行基准测试，通过`-bench`参数可以指定运行哪个基准测试。

## Go运行时调度器

在这一章中，晁老师讲到了Go运行时调度器的一些基本概念，本人就在这里做一个简单的总结。

Go运行时调度器是Go语言的一个重要组成部分，它负责管理goroutine的调度，包括创建、销毁、调度等。Go运行时调度器的主要特点有：

- MPG模型：M（Machine）代表操作系统的线程，P（Processor）代表处理器，G（Goroutine）代表goroutine。M和P是一对一的关系，而G则是多对一的关系。

- 调度器的三个阶段：调度器的三个阶段分别是P的创建、G的创建和G的调度。

- P的创建：P的创建是在程序启动时创建的，P的数量是固定的，可以通过`GOMAXPROCS`环境变量来设置P的数量。（经验法则：I/O密集型任务时一般为CPU的核心数几十倍，CPU密集型任务时一般为CPU的核心数）

- G的创建：G的创建是在程序运行时创建的，G的数量是动态的，可以通过`runtime.GOMAXPROCS`函数来设置G的数量。

- G的调度：G的调度是在程序运行时进行的，调度器会根据G的状态来进行调度，包括G的创建、销毁、调度等。

- 队列：调度器中有两种队列，分别是全局队列和本地队列。全局队列是所有P共享的队列，本地队列是每个P独有的队列。

::: info

封面来源: [pixiv](https://www.pixiv.net/artworks/108461210) <br>
参考资料: [《深入理解Go并发编程》](https://item.jd.com/14283252.html)

:::

